The engine is called from Coordinator.jar - it's the file that is executed
    It is run with java -jar connect_4_coordinator.jar
    Arguments include:
        (required) e0 <path> where <path> is the directory containing the Interface file which includes the main method of the engine
        (optional) e1 <path> where <path> is for another engine
        (optional) time x, where x is the amount of time each engine can use
        (optional) perft x where x is the depth of perft the engine should use

Coordinator to engine: name
    respond with enginename-c3293398

Coordinator to engine: isready
    when engine ready, respond with readyok
    At this point the engine should really just be initialising - no calculations yet

Coordinator to engine: position startpos <moves>
    the current order of moves. If I understand correctly, it is the column number (0-6) of each move that's happened so far.
        i.e. if each move has just been filling out along the bottom, <moves> will be 0123456
    Followed by isready, respond with readyok

Coordinator to engine: go ftime x stime y
    Tells engine to start calculating. x is time remaining for the player in milliseconds. y is how long the other player has left.
    Reply should be bestmove z v, where z is the column number, and v is the value of the evaluation function.

Coordinator to engine: perft x
    Tells the engine to count how many nodes are in the entire search tree when expanded to depth x from current position
    it is a performance test
    Should be separate from the minimax algorithm
    Responds with perft x y where x is the value it received, and y is the number of nodes searched

Coordinator to engine: quit
    Tells the engine to quit. reply should be quitting.



HOW do we know if we're player 1 or 2? if we went first or second?
    I don't think it matters, we just need to compare moves made at odd and even indices of movesList.
    If the next move is odd, and we have to calculate bestmove, then we count the odd moves as ours, and vice versa


========PROGRAM STRUCTURE==========

There should be a Game object which contains all the information relating to a single Game
    It needs to hold the board, moves (as a string)
    Or should that just be held in main, with an initialiseGame function??

Board is a 6x7 int array
    Needs to be initialised to all zeroes

When coordinator sends <moves> to the engine, it should compare <moves> with it's internal moves list, moveslist
    If <moves> does not contain moveslist as a substring, then we need to rebuild the board
    Otherwise, process the additional information on the end 
    ORRRRR we just iterate through <moves>. If the index is less than the length of moveslist, we compare with the the value at that index of moveslist.
        If it's different to moveslist at any point, then we trigger a function to just rebuild the boardstate from <moves>
        Also if <moves> is shorter than moveslist, we rebuild the board.
        If <moves> is just the same as moveslist with extra moves on the end, then we process those moves.
        Since we have to go through this before we take any move anyway, there's not really a need to add the moves our engine takes to moveslist.

When it's time to find bestmove, we need to run the evaluation function. This should be built from pseudocode / examples in the lecture notes
    Work on that as we get to it.


=======EVALUATION=================

/* basically go through the gameboard and see how many in a row we have at any point?
** 10 base points for 2 in a row
**    if can't extend to 4, ignore
**    for each direction it can be extended to 4 (each side alone + both sides), +2
**        so really a single 2 in a row will be 12, 14, or 16
**        bonus points for each extra location of a 2 in a row
** 100 base points for 3 in a row
**    if can't extend to 4, ignore
**    for each option it can be extended to 4 (each side), +20
**        so really a single 3 in a row will be 140 or 180
**        bonus points for each extra location of a 3 in a row
** 1000 base points for 4 in a row




do this a little differently - since we're searching from a single point at a time;
We order by the number of our pieces in a given neighbourhood from a piece,
    and then the open positions next to them

Horizontal // Positive // Negative:
    Single piece:
    +1, -1, +/-2    >> 5 pts
    +1, -1, +2, -2  >> 8 pts
        +1 point for each that is not just open but playable
    
    Two pieces:
    +1, -1, +/-2    >> 50 pts
    +1, -1, +2, -2  >> 80 pts
        +15 points for each that is not just open but playable
    
    Three pieces:
    +1, -1, +/-2    >> 500 pts
    +1, -1, +2, -2  >> 1000 pts
        +200 points for each that is not just open but playable
            This means we win next turn. These points will only be given once per double threat,
                as only the middle piece will meet the criteria.
            We assign more points to having two threats in one direction because this guarantees
                we have two threats that don't rely on the same play
    
 Vertical:      // With vertical we only count up. It's just easier this way.
    Single piece:
    +1              >> 5 pts
    
    Two pieces:
    +1, +2          >> 50 pts
    
    Three pieces:
    +1, +2, +3      >> 400 pts
    
 Centralisation:	// Additional points for being towards the middle
		            as it has more openings
    i = 0|6	>> pts x 1
    i = 1|5	>> (pts x 1.1) + 1
    i = 2|4	>> (pts x 1.2) + 2
    i = 3	>> (pts x 1.3) + 3
    
 


** we also need to deduct points for the opponent's options - but we can work on that later
**    this would be basically running evaluate again but for the other player
**
** remember this is just evaluating a given boardstate
** not figuring out what to do!
*/