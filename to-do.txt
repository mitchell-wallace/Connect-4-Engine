** initialiseBoard
** updateMovesList
** bestMove
    calls evaluate, which will, for now, just return (moveslist.length)+1%7 as position,
        and 10 as it's evaluated value
DONE


** pseudo for evaluate
** methods for main to talk to coordinator
DONE

** set up for minimax;
    we need a search tree
    7 children for each node? (7 possible moves each turn)
DONE
    
** build score calc for evaluate
** set up 2 player calc for evaluate
** set up syntax for eval calls in minimax
DONE

fix eval so we don't get scores of 1 billion for going in the middle

So. Evaluation scores are getting stupid inflated somewhere.
Somewhere we end up with boardstates of 1010101 along the bottom with a moveslist of 0123456
    This is in the root node from minimax start.
    None of the other nodes in the tree have even remotely correct boardstates.
    Also this is without performMove being executed once.



public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)


    src − This is the source array.

    srcPos − This is the starting position in the source array.

    dest − This is the destination array.

    destPos − This is the starting position in the destination data.

    length − This is the number of array elements to be copied.

    System.arraycopy(.....)

Well tree building works now. Boardstates are now correctly 2s and 1s. PerformMove is being performed, I was just checking the wrong one.
The evaluation function still seems leaky.
It also doesn't seem to work unless the tree is built with depth one more than minimax.
Also it's not deciding on very good moves.
Also position startpos doesn't work.


UPDATE. position startpos works, printG works.
Now I can judge the evaluation function.
    It does something at least? player one goes on the far right, player 2 on the far left, but player 2 will block the vertical four in a row
    I think it skews too heavily towards positions it can play right now, and not enough towards the middle.
    Ok so it straight up doesn't work. Scores just don't make sense, increasing depth doesn't stop it from always tring to go to column 6


Things to fix:
    Figure out how to skip evaluation of moves that are illegal.
    Skipping them in buildTree seemed to end up with minimum/maximum scores, but I think they must have been flipped
        because it seemed to prioritise them still
        >> Maybe impose a penalty to players making moves too high up? Having your pieces in j=4/5 is points for 
            your opponent?
            >> If it at least fills out the lower rows more, it will look more like it's actually working
    Use breakpoints and PROPERLY step through the minimax/evaluation process to figure out what's going wrong.
    I don't think copying someone else's evaluation function is really necessary here;
        the one I've designed should at least be fixable.
            >> It needs to not use scalars on points for p1/p2. It doesn't work how I thought it would, just breaks stuff
            >> I think it currently looks for open spots and full chains but doesn't value the in-between stages?
            >> Check that positive and negative evaluation results are correctly selected;
                that players aren't taking the wrong moves for themselves

    Skipping invalid moves;
        performMove now returns a boolean indicating whether or not a legal move was performed.
        Building a tree should now check if a move is legal before that node is added - otherwise it should be a null
        minimax needs to check if a node is !null before using it

    We shouldn't be calling minimax on a node that is null to start with.
        A not-null node can have null children. A null node will not have children.
        node.getChildren will be fine on any not-null node.
        It's only if a column is already full that minimax has issues.
        >>It was a problem in minimaxStart. Should no longer have any null pointer exceptions from minimax.

    